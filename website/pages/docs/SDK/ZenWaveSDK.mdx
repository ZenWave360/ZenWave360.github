---
section: ZenWave SDK
title: ZenWave SDK
slug: /docs/zenwave-sdk
order: 0
---
import { x } from '@xstyled/styled-components'
import { Image, Quote, QuoteAuthor } from "smooth-doc/components";
import modelingLanguagesDark from './images/SDK-ModelingLanguages.dark.png'
import modelingLanguagesLight from './images/SDK-ModelingLanguages.light.png'
import sdkHexagonalDark from './images/SDK-ServiceImplementation-Hexagonal.dark.png'
import sdkHexagonalLight from './images/SDK-ServiceImplementation-Hexagonal.light.png'
import sdkMindMapDark from './images/SDK-MindMap.dark.png'
import sdkMindMapLight from './images/SDK-MindMap.light.png'
import speedFeedbackLoopLight from './images/ZenWave-SDK-Design-Code-Loop.light.png'
import speedFeedbackLoopDark from './images/ZenWave-SDK-Design-Code-Loop.dark.png'
import sdkGeneratedCode from './images/SDK-Generated-Code.png'


# ZenWave SDK
ZenWave SDK Helps you Create Software Easy to Understand

<div class="badges">
[![Maven Central](https://img.shields.io/maven-central/v/io.github.zenwave360.zenwave-sdk/zenwave-sdk.svg?label=Maven%20Central&logo=apachemaven)](https://search.maven.org/artifact/io.github.zenwave360.zenwave-sdk/zenwave-sdk)
[![GitHub release (latest by date)](https://img.shields.io/github/v/release/ZenWave360/zenwave-sdk?logo=GitHub)](https://github.com/ZenWave360/zenwave-sdk/releases)
[![build](https://github.com/ZenWave360/zenwave-sdk/workflows/build/badge.svg)](https://github.com/ZenWave360/zenwave-sdk/actions/workflows/build.yml)
[![coverage](https://raw.githubusercontent.com/ZenWave360/zenwave-sdk/badges/jacoco.svg)](https://github.com/ZenWave360/zenwave-sdk/actions/workflows/build.yml)
[![branches coverage](https://raw.githubusercontent.com/ZenWave360/zenwave-sdk/badges/branches.svg)](https://github.com/ZenWave360/zenwave-sdk/actions/workflows/build.yml)
[![GitHub](https://img.shields.io/github/license/ZenWave360/zenwave-sdk)](https://github.com/ZenWave360/zenwave-sdk/blob/main/LICENSE)
</div>

<Quote>
    The heart of software is its ability to solve domain-related problems for its users. The best software supports elegant solutions to real-world problems
    <QuoteAuthor>- Eric Evans in Domain Driven Design</QuoteAuthor>
</Quote>

<Image alt="ZenWave SDK Modeling Languages" light={modelingLanguagesLight} dark={modelingLanguagesDark} />

ZenWave SDK is a set of tools to convert your [Domain Models](/docs/domain-modeling/business-domain-modeling) into working software and tests.

It is designed to be modular, configurable and extensible. It uses the standard java classpath as loading mechanism, so you can extend its functionality adding your own custom plugins.

Based on **Domain Driven Design (DDD)** and **API-First** principles for **Event Driven Microservices**.

<Image alt="Speed Feedback Loop" dark={speedFeedbackLoopDark} light={speedFeedbackLoopLight} style={{marginTop: '15px'}}/>

ZenWave SDK can generate code from a mix of different models including:

- [ZDL Domain Language](/docs/event-driven-design/zenwave-domain-language) as **Ubiquitous Language**. You can describe the core of your Bounded Context, as well as how it connects to external systems through different adapters and APIs.
- [AsyncAPI](https://www.asyncapi.com/docs/getting-started/coming-from-openapi): Industry de-facto standard to describe Event-Driven Architectures for Message-based APIs.
- [OpenAPI](https://swagger.io/specification/): Industry standard for Request-Response Architectures with REST APIs.

Using ZenWave Domain Language as **Ubiquitous Language** for modeling and describing Bounded Contexts: aggregates, entities with their relationships, services, value objects, commands and events.

ZenWave Domain Language started as an *extended subset* of [JHipster Domain Language (JDL)](https://www.jhipster.tech/jdl/intro) that let you describe your entities and relationships.

Using ZDL Domain Language as **Ubiquitous Language** for **Data on the Inside** and **API-First** specs like **AsyncAPI** and **OpenAPI** to describe Inter Process Communications (IPC) for **Data on the Outside**.


- **ZenWave Domain Language (ZDL) as Ubiquitous Language:** To describe your domain core domain model.
- **API-First specs like AsyncAPI and OpenAPI:** to describe Inter Process Communications (IPC) between bounded contexts/microservices.
- **ZenWave SDK:** to generate (_a lot of_) infrastructure, functional and testing code from your models and APIs.

ZenWave SDK is designed to be easily extensible and adaptable to your project or your organization needs and likes.

## ZenWave SDK Installation

### Command Line Interface (CLI)

You can install the latest release using [jbang](https://www.jbang.dev) running the following command:

```shell
jbang alias add --fresh --name=zw release@zenwave360/zenwave-sdk

jbang zw --help list

```
Will output a list of all available plugins:

```log
ZW> SDK (1.3.0)

Available plugins:

backend-application-default    io.zenwave360.sdk.plugins.BackendApplicationDefaultPlugin: Generates a full backend application using a flexible hexagonal architecture (1.3.0)
spring-cloud-streams3-adapters io.zenwave360.sdk.plugins.SpringCloudStreams3AdaptersPlugin: Generates tests for Spring Cloud Streams Consumers. (1.3.0)
jdl-to-asyncapi                io.zenwave360.sdk.plugins.JDLToAsyncAPIPlugin: Generates a full AsyncAPI definitions for CRUD operations from JDL models (1.3.0)
spring-webtestclient           io.zenwave360.sdk.plugins.SpringWebTestClientPlugin: Generates test for SpringMVC or Spring WebFlux using WebTestClient based on OpenAPI specification. (1.3.0)
fork-plugin                    io.zenwave360.sdk.plugins.ForkPlugin: Creates a new standalone maven module cloning an existing plugin (1.3.0)
jsonschema2pojo                io.zenwave360.sdk.plugins.AsyncApiJsonSchema2PojoPlugin: Generate Plain Old Java Objects from OpenAPI/AsyncAPI schemas or full JSON-Schema files (1.3.0)
spring-cloud-streams3-tests    io.zenwave360.sdk.plugins.SpringCloudStreams3TestsPlugin: Generates tests for Spring Cloud Streams Consumers. (1.3.0)
openapi-controllers            io.zenwave360.sdk.plugins.OpenAPIControllersPlugin: Generates implementations based on JDL models and OpenAPI definitions SpringMVC generated OpenAPI interfaces. (1.3.0)
openapi-to-jdl                 io.zenwave360.sdk.plugins.OpenAPIToJDLPlugin: Generates JDL model from OpenAPI schemas (1.3.0)
spring-cloud-streams3          io.zenwave360.sdk.plugins.SpringCloudStreams3Plugin: Generates strongly typed SpringCloudStreams3 producer/consumer classes for AsyncAPI (1.3.0)
rest-assured                   io.zenwave360.sdk.plugins.RestAssuredPlugin: Generates REST-Assured tests based on OpenAPI specification. (1.3.0)
zdl-to-openapi                 io.zenwave360.sdk.plugins.ZDLToOpenAPIPlugin: Generates a full OpenAPI definitions for CRUD operations from JDL models (1.3.0)
zdl-to-markdown                io.zenwave360.sdk.plugins.ZdlToMarkdownPlugin: Generates Markdown glossary from Zdl Models (1.3.0)
zdl-to-asyncapi                io.zenwave360.sdk.plugins.ZDLToAsyncAPIPlugin: Generates a full OpenAPI definitions for CRUD operations from JDL models (1.3.0)


Use: "jbang zw -p <plugin | short-code> -h" to get help on a specific plugin
```

If you don't find the functionality you are looking for, you can always [fork an existing, standard or custom plugin](https://github.com/ZenWave360/zenwave-sdk/#forking-an-standard-or-custom-plugin).

Please refer to [**ZenWave SDK**](https://github.com/ZenWave360/zenwave-sdk/) for more detailed installation options.

### Maven Plugin

You can run any available (standard or custom) plugin as part of your maven build using the maven plugin:

<details>
    <summary>Click to see the maven plugin configuration</summary>

```xml
<plugin>
    <groupId>io.github.zenwave360.zenwave-sdk</groupId>
    <artifactId>zenwave-sdk-maven-plugin</artifactId>
    <version>${zenwave.version}</version>
    <plugin>
        <includeProjectClasspath>false</includeProjectClasspath><!-- default is false -->
        <addCompileSourceRoot>true</addCompileSourceRoot><!-- default is true -->
        <addTestCompileSourceRoot>true</addTestCompileSourceRoot><!-- default is true -->
    </plugin>
    <executions>
        <!-- Add executions for each generation here: -->
        <execution>
            <id>generate-asyncapi</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>generate</goal>
            </goals>
            <plugin>
                <generatorName>spring-cloud-streams3</generatorName>
                <inputSpec>classpath:model/asyncapi.yml</inputSpec>
                <configOptions>
                    <!-- ... -->
                    <optionName>value</optionName>
                </configOptions>
            </plugin>
        </execution>
    </executions>

    <!-- add any sdk plugin (custom or standard) as dependency here -->
    <dependencies>
        <dependency>
            <groupId>io.github.zenwave360.zenwave-sdk.plugins</groupId>
            <artifactId>asyncapi-spring-cloud-streams3</artifactId>
            <version>${zenwave.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.zenwave360.zenwave-sdk.plugins</groupId>
            <artifactId>asyncapi-jsonschema2pojo</artifactId>
            <version>${zenwave.version}</version>
        </dependency>
    </dependencies>
</plugin>
```
Notice how you can read spec files from the project classpath as well as the filesystem. If you want to read a spec file from inside a project dependency remember to set `<includeProjectClasspath>true</includeProjectClasspath>`.

NOTE: Remember to add any plugin you want to use as dependency.
</details>

Jump to [ZenWave AsyncAPI Generator](https://zenwave360.github.io/zenwave-sdk/plugins/asyncapi-spring-cloud-streams3) for multiple examples using the maven plugin.


## ZenWave SDK Workflow

You can generate complete Event Driven Microservices using DDD and API-First principles:

> 👉 Describe your Domain Model ⤳ Generate OpenAPI ⤳ Generate AsyncAPI → Generate API Implementations → Generate Backend → Generate Tests and Contracts 👍

1. Start by Modeling your Domain using the ZDL Domain Language including: entities, relationships, service commands and domain events.
2. Generate a draft OpenAPI definition from the ZDL model. Edit collaboratively this OpenAPI document and then generate some more functional code and tests from that definition.
3. Generate a draft AsyncAPI definition for consuming async request commands and publishing domain events. Now use zenwave maven plugin to generate strongly typed business interfaces implementing some Enterprise Integration Patterns like: transactional outbox, business dead letter queue...
4. Generate a complete Backend Application from your Domain Definition Model.
5. Connect (by hand) your Backend Application to other systems using the generated OpenAPI and AsyncAPI definitions.
6. Generate E2E, Integration tests and Consumer Contracts for the public APIs you just produced.

<Image alt="ZenWave SDK Features MindMap" light={sdkMindMapLight} dark={sdkMindMapDark} />

<details markdown="1">
  <summary>ZenWave SDK Code Generator Features (expand to see)</summary>
- [x] JDL Backend Application (flexible hexagonal architecture)
  - [x] Domain Entities,
  - [x] Inbound
    - [x] Service Ports, DTOs, Mappers
    - [x] Implementation for CRUD operations
    - [x] Acceptance Tests: SpringData InMemory Repositories
  - [x] Outbound: SpringData Repositories, ElasticSearch... (for REST or Async see other plugins)
  - [x] Adapters:
    - [x] Spring MVC
    - [ ] ~~Spring WebFlux~~
  - [x] Flavors
    - [x] MongoDB
      - [x] Imperative
      - [ ] ~~Reactive~~
    - [x] JPA
      - [x] Imperative
      - [ ] ~~Reactive~~
  - [x] Unit/Integration Testing
    - [x] Edge Integration Testing: partial spring-boot context for outbound adapters (with testcontainers)
    - [x] Sociable Vertical Testing: manual dependency setup with in memory infrastructure _test-doubles_
    - [x] Vertical Integration Testing: full spring-boot context for inbound adapters (with testcontainers)
- [x] JDL OpenAPI Controllers
- [x] OpenAPI to Spring WebTestClient
- [x] AsyncAPI Spring Cloud Streams3
  - [x] Consumer and Producer. Imperative and Reactive.
    - [x] Business Exceptions Dead Letter Queues Routing
  - [x] Producer with Transactional Outbox pattern
    - [x] For MongoDB
    - [x] For JDBC
  - [x] Enterprise Envelop Pattern
  - [x] Automatically fill headers at runtime from payload paths, tracing-id supplier...
- [x] JDL to Specs
  - [x] JDL to OpenAPI
  - [x] JDL to AsyncAPI
    - [x] AsyncAPI schemas
    - [x] AVRO schemas
- [x] API Testing
  - [x] KarateDSL
    - [x] OpenAPI to Karate E2E Tests (please use [KarateIDE VSCode Extension](https://github.com/ZenWave360/karate-ide) instead)
    - [x] OpenAPI to Karate/ApiMock Stateful Mocks (please use [KarateIDE VSCode Extension](https://github.com/ZenWave360/karate-ide) and [ZenWave ApiMock](https://github.com/ZenWave360/zenwave-apimock) instead)
  - [x] OpenAPI to Spring WebTestClient
  - [x] OpenAPI to REST-assured
  - [ ] ~~OpenAPI to Pact (_postponed sine die_)~~
- [x] Reverser Engineering
  - [x] OpenAPI 2 JDL
  - [x] Java 2 JDL
    - [x] Spring Data MongoDB annotations
    - [x] JPA annotations

</details>

## Generated Code Structure

Generated code follows a flexible onion/hexagonal architecture. Separating core, inbound, implementation and outbound form infrastructure and adapters.

Core domain entities and aggregates are annotated for persistence with JPA or SpringData/MongoDB annotations, avoiding unnecessary translation layers (mappers and dtos).

<Image alt="ZenWave SDK Modeling Languages" src={sdkHexagonalDark} />

Project structure:

```
📦 <basePackage>
   📦 adapters
       └─ web
       |  └─ RestControllers (spring mvc)
       └─ events
          └─ *EventListeners (spring-cloud-streams)
   📦 core
       ├─ 📦 domain
       |     └─ (entities and aggregates)
       ├─ 📦 inbound
       |     ├─ dtos/
       |     └─ ServiceInterface (inbound service interface)
       ├─ 📦 outbound
       |     ├─ mongodb
       |     |  └─ *RepositoryInterface (spring-data interface)
       |     └─ jpa
       |        └─ *RepositoryInterface (spring-data interface)
       └─ 📦 implementation
             ├─ mappers/
             └─ ServiceImplementation (inbound service implementation)
   📦 infrastructure
     ├─ mongodb
     |  └─ CustomRepositoryImpl (spring-data custom implementation)
     └─ jpa
        └─ CustomRepositoryImpl (spring-data custom implementation)
```

<a href={sdkGeneratedCode}>
<Image alt="ZenWave SDK Generated Code Screenshot" src={sdkGeneratedCode} />
</a>
