---
layout: page
title: Transactional Outbox
permalink: /Event-Driven-Architectures/Enterprise-Integration-Patterns/Transactional-Outbox
parent: Enterprise Integration Patterns
grand_parent: Event Driven Architectures
nav_order: 1
---

# Transactional Outbox

## With MongoDB Transactional Outbox

This document is still a DRAFT, see the **AsyncAPI ApiFirst Generator KitchenSink** project for a working example:

https://github.com/ZenWave360/AsyncAPI-ApiFirst-Generator-KitchenSink/#with-mongodb-transactional-outbox

```xml
<execution>
    <id>generate-asyncapi-producer-outbox-mongodb</id>
    <phase>generate-sources</phase>
    <goals>
        <goal>generate</goal>
    </goals>
    <plugin>
        <generatorName>spring-cloud-streams3</generatorName>
        <inputSpec>classpath:model/asyncapi.yml</inputSpec>
        <configOptions>
            <role>provider</role>
            <style>imperative</style>
            <transactionalOutbox>mongodb</transactionalOutbox>
            <apiPackage>io.zenwave360.example.core.events.outbound.outbox.mongodb</apiPackage>
            <modelPackage>io.zenwave360.example.core.events.model</modelPackage>
        </configOptions>
    </plugin>
</execution>
```

```java
// Example implementation of a MongoDB ChangeStream listener
@Bean(destroyMethod = "stop")
public MessageListenerContainer configCustomerEventOutboxCollectionChangeStreams(
        MongoTemplate template, 
        CustomerEventsProducer customerEventsProducer // this is your autogenerated producer
        ) {
    var changeStreamOptions = ChangeStreamOptions.builder();
    // getting refresh token from autogenerated producer
    var resumeToken = customerEventsProducer.getOnCustomerEventResumeToken();
    if(resumeToken != null) {
        changeStreamOptions.resumeAfter(resumeToken);
    }

    // improve performance by persisting resume token only after 10 messages
    customerEventsProducer.skipMessagesBeforePersistingResumeToken = 10;

    final var container = new DefaultMessageListenerContainer(template);
    final var options = new ChangeStreamRequestOptions(null, customerEventsProducer.onCustomerEventOutboxCollection, changeStreamOptions.build());
    // registering autogenerated listener 'customerEventsProducer.onCustomerEventMongoChangeStreamsListener'
    container.register(new ChangeStreamRequest<>(customerEventsProducer.onCustomerEventMongoChangeStreamsListener, options), Map.class);
    container.start();
    return container;
}
```

### With JDBC Transactional Outbox

This document is still a DRAFT, see the **AsyncAPI ApiFirst Generator KitchenSink** project for a working example:

https://github.com/ZenWave360/AsyncAPI-ApiFirst-Generator-KitchenSink/#with-plain-sql-transactional-outbox

```xml
<execution>
    <id>generate-asyncapi-producer-outbox-jdbc</id>
    <phase>generate-sources</phase>
    <goals>
        <goal>generate</goal>
    </goals>
    <plugin>
        <generatorName>spring-cloud-streams3</generatorName>
        <inputSpec>classpath:model/asyncapi.yml</inputSpec>
        <configOptions>
            <role>provider</role>
            <style>imperative</style>
            <transactionalOutbox>jdbc</transactionalOutbox>
            <apiPackage>io.zenwave360.example.core.events.outbound.outbox.jdbc</apiPackage>
            <modelPackage>io.zenwave360.example.core.events.model</modelPackage>
        </configOptions>
    </plugin>
</execution>
```
```java
// Not ready for production example implementation of a JDBC outbox pulling listener
@Autowired
JdbcTemplate jdbcTemplate;

@Autowired
CustomerEventsProducer customerEventsProducer;

@Scheduled(fixedDelay = 1000)
public void pullCustomerEventsProducerOutbox() {
    String tableName = customerEventsProducer.onCustomerEventOutboxTableName;
    log.info("Pulling outbox table: {}", tableName);
    var rows = jdbcTemplate.queryForList("SELECT * FROM " + tableName + " WHERE sent_at IS NULL ORDER BY id ASC");
    log.info("Found {} rows", rows.size());
    for (var row : rows) {
        try {
            processCustomerEventsProducerOutboxRow(row, tableName);
        } catch (Exception e) {
            e.printStackTrace();
            break;
        }
    }
}

@Transactional(propagation = Propagation.REQUIRES_NEW)
public void processCustomerEventsProducerOutboxRow(Map<String, Object> row, String tableName) throws Exception {
    customerEventsProducer.sendOutboxMessage(row);
    jdbcTemplate.update("UPDATE " + tableName + " SET sent_at = current_timestamp() WHERE id = ?", row.get("id"));
}
```

## With Debezium SQL Transactional Outbox

Coming soon...
