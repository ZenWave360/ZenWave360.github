---
layout: page
title: AsyncAPI Code Generator
permalink: /Event-Driven-Architectures/AsyncAPI-Code-Generator
parent: Event Driven Architectures
nav_order: 3
---

![AsyncAPI and Spring Cloud Streams 3](https://zenwave360.github.io/zenwave-code-generator/docs/ZenWave360-AsyncAPI-SpringCloudStreams.excalidraw.svg)


## API-First with AsyncAPI and ZenWave Code Generator

With ZenWave's `spring-cloud-streams3` and `jsonschema2pojo` generator and [maven plugin](/ZenWave-Code-Generator/Maven-Plugin) you can generate strongly typed business interfaces and DTOs from AsyncAPI definitions.

It encapsulates SpringCloud Streams 3 API creating abstractions for many Enterprise Integration Patterns for Event Driven Architectures like: Transactional Outbox, Business DeadLetterQueue, Enterprise Envelop, Async Request/Response... behind business oriented interfaces.


```xml
<plugin>
    <groupId>io.github.zenwave360.zenwave-code-generator</groupId>
    <artifactId>zenwave-code-generator-mojo</artifactId>
    <version>${zenwave.version}</version>
    <executions>
        <execution>
            <id>generate-asyncapi-producer</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>generate</goal>
            </goals>
            <plugin>
                <generatorName>spring-cloud-streams3</generatorName>
                <inputSpec>${pom.basedir}/src/main/resources/model/asyncapi.yml</inputSpec>
                <configOptions>
                    <role>provider</role><!-- provider or client -->
                    <style>imperative</style>
                    <apiPackage>io.zenwave360.example.adapters.events.provider</apiPackage>
                    <modelPackage>io.zenwave360.example.adapters.events.model</modelPackage>
                </configOptions>
            </plugin>
        </execution>
        <execution>
            <id>generate-asyncapi-producer-dtos</id>
            <phase>generate-sources</phase>
            <goals>
                <goal>generate</goal>
            </goals>
            <plugin>
                <generatorName>jsonschema2pojo</generatorName>
                <inputSpec>${pom.basedir}/src/main/resources/model/asyncapi.yml</inputSpec>
                <configOptions>
                    <modelPackage>io.zenwave360.example.adapters.events.model</modelPackage>
                </configOptions>
            </plugin>
        </execution>
    </executions>
    <dependencies>
        <dependency>
            <groupId>io.github.zenwave360.zenwave-code-generator.plugins</groupId>
            <artifactId>asyncapi-spring-cloud-streams3</artifactId>
            <version>${zenwave.version}</version>
        </dependency>
        <dependency>
            <groupId>io.github.zenwave360.zenwave-code-generator.plugins</groupId>
            <artifactId>asyncapi-jsonschema2pojo</artifactId>
            <version>${zenwave.version}</version>
        </dependency>
    </dependencies>
</plugin>
```

![ZenWave StreamCloudStreams AsyncAPI](/resources/spring-cloud-streams3-generated.png)

### Spring Cloud Streams Producer (Generated Code)

On the producer side generates:

- Interface `ICustomerEventsProducer` to produce typed messages that uses your domain names: `onCustomerEvent`, `CustomerEventPayload`.
- Producer _@Component_ `CustomerEventsProducer` you can autowire in your services.

This producer component can implement different integration patterns like transactional outbox (for mongodb and sql) or enterprise envelop depending on how you configure zenwave maven generator.

```java
// Autogenerated: you can @Autowire it in your code
public interface ICustomerEventsProducer {

    boolean onCustomerEvent(CustomerEventPayload payload, Header... headers);

}
```

```java
// Autogenerated: add it to your autoscan packages
@Component
public class CustomerEventsProducer implements ICustomerEventsProducer {

    @Autowired
    private StreamBridge streamBridge;
    public String onCustomerEventBindingName = "on-customer-event-out-0";

    public boolean onCustomerEvent(CustomerEventPayload payload, Header... headers) {
        Message message = MessageBuilder.createMessage(payload, asMessageHeaders(headers));
        return streamBridge.send(onCustomerEventBindingName, message);
    }

    protected MessageHeaders asMessageHeaders(Header... headers) {
        Map<String, Object> map = Header.asMap(headers);
        return new MessageHeaders(map);
    }
}

```


### Spring Cloud Streams Consumer (Generated Code)

On the consumer side generates:

- Functional Consumer `DoCustomerRequestConsumer`  for Spring Cloud Streams bindings.
- Business Interface `IDoCustomerRequestConsumerService` you need to implement in order to receive strongly typed messages.

This Functional Consumer can abstract away different integration patterns like Business Dead Letter Queue and others... depending on how you configure zenwave maven generator.

```java
// Autogenerated: implement this interface to receive typed messages
public interface IDoCustomerRequestConsumerService {

    default void doCustomerRequest(CustomerRequestPayload payload, Map<String, Object> headers) {};
}

```

```java
// Autogenerated: add it to your auto-scan packages and implement interface above
@Component("do-customer-request")
public class DoCustomerRequestConsumer implements Consumer<Message<CustomerRequestPayload>> {

    private Logger log = LoggerFactory.getLogger(getClass());

    @Autowired
    private IDoCustomerRequestConsumerService service;

    @Autowired
    private StreamBridge streamBridge;

    @Value("${spring.cloud.stream.bindings.do-customer-request-in-0.dead-letter-queue-binding-name:null}")
    private String deadLetterQueue;

    @Override
    public void accept(Message<CustomerRequestPayload> message) {
        log.debug("Received message: {}", message);
        try {
            Object payload = message.getPayload();
            if(payload instanceof CustomerRequestPayload) {
                service.doCustomerRequest((CustomerRequestPayload) payload, message.getHeaders());
                return;
            }
            log.warn("Received message without any business handler: [payload: {}, message: {}]", payload.getClass().getName(), message);
        } catch (Exception e) {
            log.error("Error processing message: {}", message, e);
            if (streamBridge != null && deadLetterQueue != null) {
                log.debug("Sending message to dead letter queue: {}", deadLetterQueue);
                try {
                    streamBridge.send(deadLetterQueue, MessageBuilder.fromMessage(message).build());
                } catch (Exception e1) {
                    log.error("Error sending message to dead letter queue: {}", deadLetterQueue, e1);
                }
            }
            throw e;
        }
    }
}
```

## Enterprise Integration Patterns

Because access to the underlying broker is encapsulated behind the generated interfaces, it's possible to implement many Enterprise Integration Patterns (EIP) on top of them.

- [Transactional Outbox:](Enterprise-Integration-Patterns/Transactional-Outbox) for MongoDB, plain JDBC and Debezium SQL
- [Business DeadLetterQueue](Enterprise-Integration-Patterns/Business-Dead-Letter-Queue)
- [Enterprise Envelop](Enterprise-Integration-Patterns/Enterprise-Envelop)
- [Async Request/Response](Enterprise-Integration-Patterns/Async-Request-Response) (comming soon with AsyncAPI v3)
